{
  "hash": "2b0c21d81d5947fdf9eb4269f38c256a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"S1.3 设计算法\"\ndate: 2025/2/18\ncategories: [算法, 《算法导论》]\ndescription: \"介绍有关分治法的有关内容\"\n---\n\n\n插入排序使用了增量方法，在本文章中考虑一种分治法。\n\n# 分治法\n\n分治模式在每层递归式都有三个步骤：\n\n-   分解：分解原问题为若干个子问题，这些问题式原问题的规模较小的实例。\n-   解决：解决这些子问题，递归地求解各子问题。\n-   合并：将这些子问题的解合并为原问题的解。\n\n# 归并排序\n\n归并排序是一种基于分治思想的高效排序算法。它通过递归地将数组分成两部分，直到每个子数组只有一个元素，然后将这些有序的子数组逐步合并，最终形成一个完整的有序数组。\n\n其三个步骤如下：\n\n-   分解：分解待排序的n个元素的序列成各具n/2个元素的两个子序列。\n-   解决：使用归并排序递归地排序两个子序列\n-   合并：合并两个已排序的子序列以产生已排序的答案。\n\n## 合并\n\n::: panel-tabset\n## 伪代码\n\n``` pseudocode\n\\begin{algorithm}\n\\caption{合并(A,p,q,r)}\n\\begin{algorithmic}\n    \\State $n_1=q-p-1$\n    \\State $n_2=r-q$\n    \\State 声明两个数组L[1..$n_1$+1]和R[1..$n_2$+1]\n    \\For{i=1\\To $n_1$}\n    \\State L[i]=A[p+i-1]\\EndFor\n    \\For{j=1\\To $n_2$}\n    \\State R[j]=A[q+j]\\EndFor\n    \\State L[$n_1+1$]=$\\infty$\n    \\State R[$n_2+1$]=$\\infty$\n    \\State i=1,j=1\n    \\State \\For{k=p\\To r}\n    \\State \\If{L[i]$\\leq$ R[j]}\n    \\State A[k]=L[i]\n    \\State i=i+1\n    \\Else \n    \\State A[k]=R[j]\n    \\State j=j+1\\EndIf\\EndFor\n\\end{algorithmic}\n\\end{algorithm}\n```\n\n## python\n\n::: {#c8c3e869 .cell execution_count=1}\n``` {.python .cell-code}\ndef merge(A: list, p: int, q: int, r: int) -> list:\n    \"\"\"\n    A: 待排序的列表\n\n    p：从何处开始进行排序(左子序列的首部)\n    \n    q：两子序列分割点(右子序列的首部)\n    \n    r：待排序的两个子序列和原先列表最后一个元素的索引\n    \"\"\"\n    L = A[p:q]; R = A[q:r+1]  # 切分为两个数组\n    L.append(float(\"inf\")); R.append(float(\"inf\"))  # 添加哨兵值\n    i = 0; j = 0  # 初始化两子序列指针\n    for k in range(p, r+1):\n        if L[i] <= R[j]:\n            A[k] = L[i]\n            i = i + 1\n        else:\n            A[k] = R[j]\n            j = j + 1\n    return A\n\nA = [1, 2, 3, 4, 6, 8, 5, 7, 9]\nA = merge(A, 3, 6, 8)\nprint(f\"排序后：{A}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n:::\n:::\n\n\n## C++\n\n``` cpp\n#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nvoid merge(vector<int>& A, int p, int q, int r){\n    int n_1 = q-p, n_2 = r+1-q;\n    vector<int> L(n_1), R(n_2);\n    for (int i = 0; i<n_1; i++){\n        L[i] = A[p+i];\n    }\n    for (int i = 0; i<n_2; i++){\n        R[i] = A[q+i];\n    }\n    // 添加哨兵值\n    L.push_back(numeric_limits<int>::max());\n    R.push_back(numeric_limits<int>::max());\n    int i = 0, j = 0;\n    for (int k = p; k < r+1; k++){\n        if(L[i]<=R[j]){\n            A[k] = L[i];\n            i++;\n        }\n        else{\n            A[k] = R[j];\n            j++;\n        }\n    }\n}\n\nint main(){\n    vector<int> A = {1, 2, 3, 4, 6, 8, 5, 7, 9};\n    merge(A, 3, 6, A.size()-1);\n    cout << \"排序后：\";\n    for (int i = 0; i<A.size(); i++){\n        cout << A[i] << \" \";\n    }\n    return 0;\n}\n// 排序后：1 2 3 4 5 6 7 8 9 \n```\n:::\n\n其运行过程如下：\n\n<iframe width=\"800\" height=\"500\" frameborder=\"0\" src=\"https://pythontutor.com/iframe-embed.html#code=def%20merge%28A%3A%20list,%20q%3A%20int,%20p%3A%20int,%20r%3A%20int%29%20-%3E%20list%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20A%3A%20%E5%BE%85%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%97%E8%A1%A8%0A%0A%20%20%20%20p%EF%BC%9A%E4%BB%8E%E4%BD%95%E5%A4%84%E5%BC%80%E5%A7%8B%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%28%E5%B7%A6%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%A6%96%E9%83%A8%29%0A%20%20%20%20%0A%20%20%20%20q%EF%BC%9A%E4%B8%A4%E5%AD%90%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2%E7%82%B9%28%E5%8F%B3%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%A6%96%E9%83%A8%29%0A%20%20%20%20%0A%20%20%20%20r%EF%BC%9A%E5%BE%85%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E5%8E%9F%E5%85%88%E5%88%97%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%E6%80%BB%E5%92%8C%0A%20%20%20%20%22%22%22%0A%20%20%20%20L%20%3D%20A%5Bp%3Aq%5D%3B%20R%20%3D%20A%5Bq%3Ar%5D%20%20%23%20%E5%88%87%E5%88%86%E4%B8%BA%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%0A%20%20%20%20L.append%28float%28%22inf%22%29%29%3B%20R.append%28float%28%22inf%22%29%29%20%20%23%20%E6%B7%BB%E5%8A%A0%E5%93%A8%E5%85%B5%E5%80%BC%0A%20%20%20%20i%20%3D%200%3B%20j%20%3D%200%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%A4%E5%AD%90%E5%BA%8F%E5%88%97%E6%8C%87%E9%92%88%0A%20%20%20%20for%20k%20in%20range%28p,%20r%29%3A%0A%20%20%20%20%20%20%20%20if%20L%5Bi%5D%20%3C%3D%20R%5Bj%5D%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20A%5Bk%5D%20%3D%20L%5Bi%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20i%20%3D%20i%20%2B%201%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20A%5Bk%5D%20%3D%20R%5Bj%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20j%20%3D%20j%20%2B%201%0A%20%20%20%20return%20A%0A%0AA%20%3D%20%5B1,%202,%203,%204,%206,%208,%205,%207,%209%5D%0AA%20%3D%20merge%28A,%206,%203,%209%29%0Aprint%28f%22%E6%8E%92%E5%BA%8F%E5%90%8E%EF%BC%9A%7BA%7D%22%29&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=35&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false\">\n\n</iframe>\n\n该合并算法需要 $\\Theta(n)$ 的时间，每次基本操作是常量时间，而最多执行n个基本步骤。或者可以观察其伪代码，发现就只有一个循环需要运行 $\\Theta(n)$ 时间，而循环内的操作都是需要常量时间。 ($n=r-p$)\n\n::: callout-note\n## 合并算法正确性\n\n`循环不变式`：在k次迭代时，子数组A\\[p..k-1\\]按从小到大的顺序包含L\\[1..$n_1+1$\\]和R\\[1..$n_2+1$\\]中的 $k-p$ 个最小元素。\n\n-   初始化：易得在第一次迭代前循环不变式成立（平凡）。\n-   保持：假设第k次循环 L\\[i\\]\\< R\\[j\\]，那么此时 A\\[p,k-1\\]中将会加入L\\[i\\]，在下次循环前A\\[p,k\\]中包含的就是L\\[1..$n_1+1$\\]和R\\[1..$n_2+1$\\]中的 $k+1-p$ 个最小元素。故保持了循环不变式的成立\n-   终止：当k=r+1时循环终止，A\\[p..k-1\\]包含的元素就是L\\[1..$n_1+1$\\]和R\\[1..$n_2+1$\\]中的 $k-p$ 个最小元素，且L,R仅剩下哨兵值。\n\n综上算法成立。\n:::\n\n## 归并排序算法\n\n::: panel-tabset\n## 伪代码\n\n``` pseudocode\n\\begin{algorithm}\n\\caption{MERGE-SORT(A,p,r)}\n\\begin{algorithmic}\n    \\State \\If{p<r}\n    \\State $q=\\lfloor (p+r)/2 \\rfloor$\\EndIf\n    \\State MERGE-SORT(A,p,q)\n    \\State MERGE-SORT(A,q+1,r)\n    \\State MERGE(A,p,q,r)\n\\end{algorithmic}\n\\end{algorithm}\n```\n\n## python\n\n::: {#69915a4f .cell execution_count=2}\n``` {.python .cell-code}\nimport math\ndef MergeSort(A: list, p: int, r: int):\n    if p<r:\n        q = math.floor((p+r)/2)  # 对半切分\n        MergeSort(A, p, q)  # 切分左半边\n        MergeSort(A, q+1, r)  # 切分右半边\n        merge(A, p, q+1, r)\n\nA = [4, 2, 7, 1, 5, 6, 3, 8]\nMergeSort(A, 0, len(A)-1)\nprint(f\"排序后：{A}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n排序后：[1, 2, 3, 4, 5, 6, 7, 8]\n```\n:::\n:::\n\n\n## C++\n\n``` cpp\nvoid MergeSort(vector<int>& A, int p, int r){\n    if (p<r) {\n        int q = static_cast<int>((p+r)/2);\n        MergeSort(A, p, q);\n        MergeSort(A, q+1, r);\n        merge(A, p, q+1, r);\n    }\n}\n\nint main(){\n    vector<int> A = {4, 2, 7, 1, 5, 6, 3, 8};\n    MergeSort(A, 0, A.size()-1);\n    cout << \"排序后：\";\n    for (int i = 0; i<A.size(); i++){\n        cout << A[i] << \" \";\n    }\n    return 0;\n}\n// 排序后：1 2 3 4 5 6 7 8\n```\n:::\n\n其运行过程如下：\n\n<iframe width=\"800\" height=\"500\" frameborder=\"0\" src=\"https://pythontutor.com/iframe-embed.html#code=def%20merge%28A%3A%20list,%20p%3A%20int,%20q%3A%20int,%20r%3A%20int%29%3A%0A%20%20%20%20L%20%3D%20A%5Bp%3Aq%5D%3B%20R%20%3D%20A%5Bq%3Ar%2B1%5D%20%20%23%20%E5%88%87%E5%88%86%E4%B8%BA%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%0A%20%20%20%20L.append%28float%28%22inf%22%29%29%3B%20R.append%28float%28%22inf%22%29%29%20%20%23%20%E6%B7%BB%E5%8A%A0%E5%93%A8%E5%85%B5%E5%80%BC%0A%20%20%20%20i%20%3D%200%3B%20j%20%3D%200%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%A4%E5%AD%90%E5%BA%8F%E5%88%97%E6%8C%87%E9%92%88%0A%20%20%20%20for%20k%20in%20range%28p,%20r%2B1%29%3A%0A%20%20%20%20%20%20%20%20if%20L%5Bi%5D%20%3C%3D%20R%5Bj%5D%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20A%5Bk%5D%20%3D%20L%5Bi%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20i%20%3D%20i%20%2B%201%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20A%5Bk%5D%20%3D%20R%5Bj%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20j%20%3D%20j%20%2B%201%0A%0Aimport%20math%0Adef%20MergeSort%28A%3A%20list,%20p%3A%20int,%20r%3A%20int%29%3A%0A%20%20%20%20if%20p%3Cr%3A%0A%20%20%20%20%20%20%20%20q%20%3D%20math.floor%28%28p%2Br%29/2%29%20%20%23%20%E5%AF%B9%E5%8D%8A%E5%88%87%E5%88%86%0A%20%20%20%20%20%20%20%20MergeSort%28A,%20p,%20q%29%20%20%23%20%E5%88%87%E5%88%86%E5%B7%A6%E5%8D%8A%E8%BE%B9%0A%20%20%20%20%20%20%20%20MergeSort%28A,%20q%2B1,%20r%29%20%20%23%20%E5%88%87%E5%88%86%E5%8F%B3%E5%8D%8A%E8%BE%B9%0A%20%20%20%20%20%20%20%20merge%28A,%20p,%20q%2B1,%20r%29%0A%0AA%20%3D%20%5B4,%202,%207,%201,%205,%206,%203,%208%5D%0AMergeSort%28A,%200,%20len%28A%29-1%29%0Aprint%28f%22%E6%8E%92%E5%BA%8F%E5%90%8E%EF%BC%9A%7BA%7D%22%29&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false\">\n\n</iframe>\n\n## 分析分治算法\n\n这种归并排序的时间可由下式表示：\n\n$$\nT(n)=\\begin{cases}\n\\Theta(1)&n\\leq c\\\\\naT(n/b)+D(n)+C(n)&\\text{其他}\n\\end{cases}\n$$\n\n上式当问题规模足够小时，仅需常量时间。而当问题规模 $n>c$ 时，原问题解决的时间由以下三部分构成：\n\n-   解决被分解后规模相当于原问题 $1/b$ 的a个子问题所耗费的时间 $aT(n/b)$\n-   分解成子问题所需要的时间 $D(n)$\n-   合并子问题成原问题的解需要的时间 $C(n)$\n\n### 归并排序算法时间复杂度分析\n\n-   分割：易得分解子问题的时间易得为常数时间。\n-   解决：为了便于分析此处假定问题的规模为2的幂数倍，则规模为 $n$ 的原问题将会被分割为2个规模为 $n/2$ 的子问题，解决这些子问题的时间为 $2T(n/2)$。\n-   合并：在归并排序算法中合并子问题的时间由上述分析得为 $\\Theta(n)$\n\n综上有如下公式： $$\nT(n)=\\begin{cases}\n\\Theta(1)&n\\leq 1\\\\\n2T(n/2)+\\Theta(n)&\\text{其他}\n\\end{cases}\n$$\n\n![归并排序算法时间分析](images/paste-1.jpeg){width=\"460\"}\n\n即归并排序算法的时间为 $\\Theta(n\\log_2n)$\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}