{
  "hash": "81343b0ab7a146cd9688fab6fc7de4c3",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"S1.1 插入排序\"\ndescription: \"《算法导论》第二章算法基础中的有关循环不变式、伪代码、插入排序的解释\"\nauthor: \"Hahabula\"\ndate: \"2025/02/06\"\ncategories:\n    - 算法\n    - 《算法导论》\nimage: logo.png\n---\n\n\n后续的算法设计于分析都是在本章框架下进行的。\n\n# 插入排序算法\n\n1）排序问题的叙述\n\n**输入**: $n$个树的一个序列$<a_1,a_2,\\ldots,a_n>$\n\n**输出**: 输入序列的一个排列$<a_1', a_2',\\ldots, a_n'>$，满足$a_1'\\leq a_2'\\leq \\ldots \\leq a_n'$\n\n2）算法的描述和实现\n\n::: panel-tabset\n### 伪代码\n\n``` pseudocode\n\\begin{algorithm}\n\\caption{插入排序(A)}\n\\begin{algorithmic}[1]\n    \\FOR{$j = 2$ \\To $A.length$}\n        \\STATE $key = A[j]$\n        \\STATE // 往$A[1..j-1]$排序好后的序列中插入$A[j]$\n        \\STATE $i = j - 1$\n        \\WHILE{$i > 0$ and $A[i] > key$}\n            \\STATE $A[i+1] = A[i]$\n            \\STATE $i = i - 1$\n        \\ENDWHILE\n        \\STATE $A[i+1] = key$\n    \\ENDFOR\n\\end{algorithmic}\n\\end{algorithm}\n```\n\n### python\n\n::: {#a6f9815e .cell execution_count=1}\n``` {.python .cell-code}\nA = [5, 2, 4, 6, 1, 3]\nprint(\"初始序列: \", A)\nfor j in range(1, len(A)): \n    key = A[j]\n    i = j - 1\n    while i>=0 and A[i]>key: \n        A[i+1] = A[i]\n        i = i - 1\n    A[i+1] = key\nprint(\"排序后:  \", A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n初始序列:  [5, 2, 4, 6, 1, 3]\n排序后:   [1, 2, 3, 4, 5, 6]\n```\n:::\n:::\n\n\n:::\n\n其运行过程如下： <iframe width=\"800\" height=\"500\" frameborder=\"0\" src=\"https://pythontutor.com/iframe-embed.html#code=A%20%3D%20%5B5,%202,%204,%206,%201,%203%5D%0Aprint%28%22%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%3A%20%22,%20A%29%0Afor%20j%20in%20range%281,%20len%28A%29%29%3A%20%0A%20%20%20%20key%20%3D%20A%5Bj%5D%0A%20%20%20%20i%20%3D%20j%20-%201%0A%20%20%20%20while%20i%3E%3D0%20and%20A%5Bi%5D%3Ekey%3A%20%0A%20%20%20%20%20%20%20%20A%5Bi%2B1%5D%20%3D%20A%5Bi%5D%0A%20%20%20%20%20%20%20%20i%20%3D%20i%20-%201%0A%20%20%20%20A%5Bi%2B1%5D%20%3D%20key%0Aprint%28%22%E6%8E%92%E5%BA%8F%E5%90%8E%3A%20%20%22,%20A%29&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=0&heapPrimitives=nevernest&origin=opt-frontend.js&py=311&rawInputLstJSON=%5B%5D&textReferences=false\"> </iframe>\n\n# 循环不变式\n`循环不变式`是一个在循环每次迭代前后都保持为真的条件或性质，帮助确保循环的行为符合预期。具体来说，循环不变式需要满足以下三个性质：\n\n- **初始化**：在循环开始之前，循环不变式为真。\n- **保持**：如果循环不变式在某次迭代之前为真，那么在执行循环体后，它仍然为真。\n- **终止**：当循环结束时，循环不变式仍然为真，并且可以用来推导出循环结束后程序的正确性。\n\n循环不变式主要用来帮助理解算法的正确性。其思想类似于数学归纳法，但循环不等式当循环停止时便停止归纳。下面将利用循环不变式证明插入排序算法的正确性，此时的循环不变式是指 $A[1]-A[j-1]$ 子序列已经按找从小到大进行排序且是原来的那些元素。\n\n- **初始化**：当 $j=2$ 时 $A[1]-A[j-1]$ 即 $A[1]$ 是从小到大的，属于平凡情况。（此时只有一个元素无所谓排序故正确）\n- **保持**：在`for`循环过程中，假设前j-1次迭代是保持循环不变式的，此时当前的 $A[j]$ 将会伺机在 $A[1]-A[j-1]$ 中向左移动直到找到属于它的位置。在找到其位置后，此时的 $A[1]-A[j]$ 仍是原来的元素且已经按照从小到大进行排序了，表明在第 $j$ 次迭代保持循环不变式。\n- **终止**：循环终止条件是`j>A.length`，此时 $j=A.length+1$ ，也即是否 $A[1]-A[A.length]$ 由原来的元素构成且按小到大排序，上述结论易得成立，故该算法正确。\n\n# 伪代码\n伪代码是一种用于解释算法的语法，可以通过Python，C，C++等高级编程语言重新编写后运行但不可直接运行。\n\n## 约定\n- `//`：表示注释\n- 缩进表示块结构\n- 数组元素通过`数组名[下标]`的形式进行访问，`A[1..j]`表示 $A[1]-A[j]$\n- 复合对象被组织成对象，其又有属性构成，即`A.length`：表示数组A的长度\n\n## 语法(Latex)\n\n- [ ] 待整理\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}