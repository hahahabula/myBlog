{
  "hash": "0da8a8c4996036fe765a2fe8013b2095",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Day3\"\ndate: 2025/02/25\ncategories: [刷题, 算法]\ndescription: \"介绍有关\"\n---\n\n\n# 寻找两正序数组中位数\n\n![](images/paste-1.png)\n\n::: {.callout-note}\n# 分析\n1. 由于限制时间复杂度为 $O\\log(m+n)$，因此可以联想到二分或者递归。\n2. 找中位数可转化为找第k大的值\n3. 选取两序列 $\\lfloor k/2\\rfloor-1$ 处的值进行比对，若A序列的小于B序列的则说明第k大的数不在A序列的左半边，可直接删去；若大于，则删除B左边的；若相等则A[$\\lfloor k/2\\rfloor-1$]或B[$\\lfloor k/2\\rfloor-1$]为第k大的数。\n4. 若处于3.中不相等的情况时，则应当转为寻找第k-$\\lfloor k/2\\rfloor$大的数。\n5. 若两数组中存在至少一个空集时，直接返回非空集的第k个元素。\n6. 若k=1，则返回A,B中第一个元素较大的。\n:::\n\n::: panel-tabset\n# 伪代码\n```pseudocode\n\\begin{algorithm}\n\\caption{findK(nums1,m,nums2,n,x)}\n\\begin{algorithmic}\n\\If{m>n}\\Comment{保证前一个传入的数组是个数较少的}\n\t\\State \\Return findK(nums2,n,nums1,x)\n\\EndIf\n\\If{m==0}\\Comment{当存在空集合时另一个集合的第x个即为所求}\n\t\\State \\Return nums2[x-1]\n\\EndIf\n\\If{x==1}\\Comment{当x为1时仅需比较两数组的首位即可}\n\t\\State \\Return min(nums1[0], nums2[0])\n\\EndIf\n\\State ia = min($\\lfloor x/2\\rfloor$,m), ib = x - ia \\Comment{保证比较前x个元素}\n\\If{nums1[ia-1]<nums2[ib-1]}\n\t\\State \\Return findK(nums1[ia..], m-ia, nums2, n, x-ia)\n\\Elif{nums1[ia-1]>nums2[ib-1]}\n\t\\State \\Return findK(nums1, m, nums2[ib..], n-ib, x-ib)\n\\Else\n\t\\State \\Return nums1[ia-1]\n\\EndIf\n\\end{algorithmic}\n\\end{algorithm}\n```\n\n```pseudocode\n\\begin{algorithm}\n\\caption{findMedian(nums1, nums2)}\n\\begin{algorithmic}\n\\State m=nums1.length,n=nums2.length\n\\If{m+n为奇数}\n\t\\State \\Return findK(nums1, m, nums2, n, (m+n+1)/2)\n\\Else\n\t\\State \\Return (findK(nums1, m, nums2, n, (m+n)/2)+findK(nums1, m, nums2, n, (m+n)/2+1))/2\n\\EndIf\n\\end{algorithmic}\n\\end{algorithm}\n```\n\n之所以此时的时间复杂度为 $O(\\log(m+n))$ 是因为算法最多会运行 $\\Theta(\\log(x))$ ，而x的上界为m+n，因此时间复杂度为 $O(\\log(m+n))$\n\n# Python\n\n::: {#a793e55b .cell execution_count=1}\n``` {.python .cell-code}\nfrom typing import List\nclass Solution:\n    def findK(self, nums1: List[int], m: int, nums2: List[int], n: int, x: int) -> float:\n        if m>n:\n            return self.findK(nums2, n, nums1, m, x)\n        if m==0:\n            return nums2[x-1]\n        if x==1:\n            return min(nums1[0], nums2[0])\n        ia = min(m, int(x/2)); ib = x - ia\n        if nums1[ia-1] < nums2[ib-1]:\n            return self.findK(nums1[ia:], m-ia, nums2, n, x-ia)\n        elif nums1[ia-1] > nums2[ib-1]:\n            return self.findK(nums1, m, nums2[ib:], n-ib, x-ib)\n        else:\n            return nums1[ia-1]\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        m = len(nums1); n = len(nums2)\n        if (m+n)%2 == 1:\n            return self.findK(nums1, m, nums2, n, int((m+n+1)/2))\n        else:\n            return (self.findK(nums1, m, nums2, n, int((m+n)/2)) + self.findK(nums1, m, nums2, n, int((m+n)/2+1)))/2\n```\n:::\n\n\n# C++\n```c++\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m = nums1.size(), n = nums2.size();\n        int total = m + n;\n        if (total % 2 != 0) return findK(nums1.begin(), m, nums2.begin(), n, total / 2 + 1);\n        else return (findK(nums1.begin(), m, nums2.begin(), n, total / 2) \n                    + findK(nums1.begin(), m, nums2.begin(), n, total / 2 + 1)) / 2.0;\n    }\nprivate:\n    static int findK(vector<int>::const_iterator nums1, int m, vector<int>::const_iterator nums2, int n, int x){\n        if (m > n) return findK(nums2, n, nums1, m, x);\n        if (m == 0) return  *(nums2 + x - 1);\n        if (x == 1) return min(nums1[0], nums2[0]);\n        int ia = min(x/2, m), ib = x - ia; \n        if (*(nums1 + ia - 1) < *(nums2 + ib -1)) return findK(nums1 + ia, m - ia, nums2, n, x - ia);\n        else if (*(nums1 + ia - 1) > *(nums2 + ib -1)) return findK(nums1, m, nums2 + ib, n - ib, x - ib);\n        else return *(nums1 + ia -1);\n    }\n};\n```\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}