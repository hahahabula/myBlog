{
  "hash": "9573c34382479c657e58af56a020f09b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Day1\"\ndate: 2025/02/23\ndescription: \"线性表中删除有序数组中的重复项、删除有序数组中的重复项Ⅱ\"\ncategories: [算法, 刷题]\n---\n\n\n# 删除有序数组中的重复项\n\n![](images/paste-1.png){width=\"712\"}\n\n::: panel-tabset\n# 伪代码\n\n``` pseudocode\n\\begin{algorithm}\n\\caption{removeDuplicates(A)}\n\\begin{algorithmic}\n\\State slow=0\n\\For{fast=1 \\To A.length-1}\n\\State \\If{A[fast]!=A[slow]}\n\\State A[slow+1] = A[fast]\n\\State slow += 1\\EndIf\\EndFor\n\\end{algorithmic}\n\\end{algorithm}\n```\n\n# Python\n\n::: {#e208e682 .cell execution_count=1}\n``` {.python .cell-code}\nfrom typing import List\n\ndef removeDuplicates(A: List[int]) -> int:\n    if not A:\n        return 0\n    slow = 0\n    for fast in range(1, len(A)):\n        if A[fast] != A[slow]:\n            A[slow+1] = A[fast]\n            slow += 1\n    return slow+1\n\nA = [1, 1, 1, 2, 2, 4, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8]\na = removeDuplicates(A)\nprint(f\"返回值:{a}\")\nprint(f\"A:{A[:a]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n返回值:6\nA:[1, 2, 4, 6, 7, 8]\n```\n:::\n:::\n\n\n# C++\n\n``` cpp\nint removeDuplicates(vector<int>& nums) {\n        if (nums.empty()) return 0;\n        int slow = 0;\n        for (int fast=1; fast<nums.size(); fast++){\n            if (nums[fast]!=nums[slow]){\n                nums[++slow] = nums[fast];\n            }\n        }\n        return slow+1;\n    }\n```\n:::\n\n::: callout-tip\n## 解决方法及证明\n\n双指针fast, slow\n\n-   fast:用以跳过重复序列并遍历整个数组\n-   slow:用以指向最后合法元素位置\n\n![](images/paste-2.png){width=\"303\"}\n\n1.  初始化：当slow在 $0$ 处, fast在1处\n2.  保持：当出现首个与目前slow不同的元素时，slow向前移动并赋值为fast所在元素，此时slow及其以前的子集符合要求。\n3.  结束：当fast达到数组尾部时，迭代停止，此时slow及其以前的子集符合要求。\n:::\n\n# 删除有序数组中的重复项Ⅱ\n\n![](images/paste-3.png)\n\n::: panel-tabset\n# 伪代码\n\n``` pseudocode\n\\begin{algorithm}\n\\caption{removeDuplicates2(A)}\n\\begin{algorithmic}\n\\State \\IF{A.length<=2}\n\\State \\Return A.length \\EndIf\n\\State slow=1\n\\State \\For{fast=2\\To A.length}\n\\State \\If{A[fast]!=A[slow-1]}\n\\State slow += 1\n\\State A[slow] = A[fast] \\EndIf \\EndFor\n\\State \\Return slow+1\n\\end{algorithmic}\n\\end{algorithm}\n```\n\n# Python\n\n::: {#dda3f1f6 .cell execution_count=2}\n``` {.python .cell-code}\ndef removeDuplicates2(A: List[int]) -> int:\n    if len(A) <=2:\n        return len(A)\n    slow = 1\n    for fast in range(2, len(A)):\n        if A[fast]!=A[slow-1]:\n            slow += 1\n            A[slow] = A[fast]\n    return slow+1\n```\n:::\n\n\n# C++\n\n``` cpp\nint removeDuplicates(vector<int>& nums) {\n        if (nums.size()<=2){\n            return nums.size();\n        }\n        int slow = 1;\n        for (int fast=2; fast<nums.size(); fast++){\n            if (nums[fast]!=nums[slow-1]){\n                nums[++slow]=nums[fast];\n            }\n        }\n        return slow+1;\n    }\n```\n:::\n\n::: callout-tip\n# 解决方法及证明\n\n双指针，fast和slow： \n\n- fast：用以遍历全数组的同时跳出重复值 \n- slow：用以记录合法子集的最后一个索引\n\n![](images/paste-4.png){width=\"563\"}\n\n`循环不变式`：slow及其以前元素组成的子集是满足要求，且其中的元素是原数组各数值出现的前两个而非其他位置的。\n\n1. 初始化：初始的slow=1即数组的前两个元素组成的子集必然满足条件。\n2. 保持：需分情况讨论，slow向前走的情况分为：1)首次添加一个元素;2)重复添加一个已经出现一次的元素。\n    \n    - 当首次添加时，slow及其以前的元素构成的子集一定满足条件（假设），此时slow-1为其他元素，在slow+1首次添加元素，且下次增加相同元素的时机是当fast来到原数组相同元素第二次出现的位置，而非其他位置，故保持循环不变式成立；\n    - 当重复添加时，易得也满足，且下一次不会再重复添加第三次因为此时slow-1为该元素，不会导致slow的更新(A[fast]!=A[slow-1])，循环不变式成立。\n3. 终止：当fast达到原数组的末尾时循环终止，此时不会再添加相同的元素和首个元素，循环不变式易得成立。\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}