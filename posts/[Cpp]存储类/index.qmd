---
title: "C++存储类"
date: 2025/2/18
categories: [C++]
description: "介绍C++中有关存储类的知识以及运算符"
---

存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。

# auto存储类
auto 关键字用于两种情况:

- 声明变量时根据初始化表达式自动推断该变量的类型
- 声明函数时函数返回值的占位符

```c++
auto f=3.14;  // double
auto s("hello");  // const char*
auto s{"hello"};  // <1>
auto z = new auto(9); // <2>
// int*
auto x1 = 5, x2 = 5.0, x3='r';  //错误，必须是初始化为同一类型
```
1. C++可用变量名(字符串)/变量名{字符串}创建字符变量
2. 首先new auto(9)解析创建一个int类型的对象，并用9进行初始化，并用z作为int*类型的指针指向这个对象

# static存储类
static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。

1. 作用于局部变量
因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。
2. 作用于全局变量
static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。
3. 作用于类数据成员
在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。

```c++
#include <iostream>
// 函数声明 
void func(void);
 
static int count = 10; /* 全局变量 */
 
int main()
{
    while(count--)  // <2>
    {
       func();
    }
    return 0;
}
// 函数定义
void func( void )
{
    static int i = 5; // <1>
    i++;
    std::cout << "变量 i 为 " << i ;
    std::cout << " , 变量 count 为 " << count << std::endl;
}

```
1. 正常而言i在每次迭代中都会重新赋值于5，但加上static属性后该语句不会再执行，且其值会在函数调用后保持
2. 此while循环中的count--即是判断条件其先将count目前返回判断是否为true，而后--，故会执行10次循环

# extern存储类
extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。即利用extern关键字修饰变量时可不进行初始化或声明从其他文件中获取，而不需再此处声明。

```c++
// main.cpp
#include <iostream>
 
int count ;
extern void write_extern();
 
int main()
{
   count = 5;
   write_extern();
}
```

```c++
// support.cpp
#include <iostream>
 
extern int count;
 
void write_extern(void)
{
   std::cout << "Count is " << count << std::endl;
}
```

::: {.callout-important}
## 使用extern关键字编译注意事项
使用`g++ main.cpp support.cpp -o write`进行编译并键入write来运行

结果为`Count is 5`
:::

# mutable存储类
mutable 是一个关键字，用于修饰类的成员变量，使其能够在 const 成员函数中被修改。通常情况下，const 成员函数不能修改对象的状态，但如果某个成员变量被声明为 mutable，则可以在 const 函数中对其进行修改，其特点如下：

- 允许修改：mutable 成员变量可以在 const 成员函数内被改变。
- 设计目的：通常用于需要在不改变对象外部状态的情况下进行状态管理的场景，比如缓存、延迟计算等。

# 杂项运算符
```c++
sizeof(a);  // 将返回变量的大小
x = a>2 ? 1:2;  // 若a>2则x的值为1反之为2
&a;  // 返回变量a的地址
*a;  // 指向变量
```



