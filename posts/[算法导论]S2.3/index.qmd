---
title: "S1.3 设计算法"
date: 2025/2/18
categories: [算法, 《算法导论》]
description: "介绍有关分治法的有关内容"
---

插入排序使用了增量方法，在本文章中考虑一种分治法。

# 分治法

分治模式在每层递归式都有三个步骤：

-   分解：分解原问题为若干个子问题，这些问题式原问题的规模较小的实例。
-   解决：解决这些子问题，递归地求解各子问题。
-   合并：将这些子问题的解合并为原问题的解。

# 归并排序

归并排序是一种基于分治思想的高效排序算法。它通过递归地将数组分成两部分，直到每个子数组只有一个元素，然后将这些有序的子数组逐步合并，最终形成一个完整的有序数组。

其三个步骤如下：

-   分解：分解待排序的n个元素的序列成各具n/2个元素的两个子序列。
-   解决：使用归并排序递归地排序两个子序列
-   合并：合并两个已排序的子序列以产生已排序的答案。

## 合并

::: panel-tabset
## 伪代码

``` pseudocode
\begin{algorithm}
\caption{合并(A,p,q,r)}
\begin{algorithmic}
    \State $n_1=q-p-1$
    \State $n_2=r-q$
    \State 声明两个数组L[1..$n_1$+1]和R[1..$n_2$+1]
    \For{i=1\To $n_1$}
    \State L[i]=A[p+i-1]\EndFor
    \For{j=1\To $n_2$}
    \State R[j]=A[q+j]\EndFor
    \State L[$n_1+1$]=$\infty$
    \State R[$n_2+1$]=$\infty$
    \State i=1,j=1
    \State \For{k=p\To r}
    \State \If{L[i]$\leq$ R[j]}
    \State A[k]=L[i]
    \State i=i+1
    \Else 
    \State A[k]=R[j]
    \State j=j+1\EndIf\EndFor
\end{algorithmic}
\end{algorithm}
```

## python

```{python}
def merge(A: list, p: int, q: int, r: int) -> list:
    """
    A: 待排序的列表

    p：从何处开始进行排序(左子序列的首部)
    
    q：两子序列分割点(右子序列的首部)
    
    r：待排序的两个子序列和原先列表最后一个元素的索引
    """
    L = A[p:q]; R = A[q:r+1]  # 切分为两个数组
    L.append(float("inf")); R.append(float("inf"))  # 添加哨兵值
    i = 0; j = 0  # 初始化两子序列指针
    for k in range(p, r+1):
        if L[i] <= R[j]:
            A[k] = L[i]
            i = i + 1
        else:
            A[k] = R[j]
            j = j + 1
    return A

A = [1, 2, 3, 4, 6, 8, 5, 7, 9]
A = merge(A, 3, 6, 8)
print(f"排序后：{A}")
```

## C++

``` cpp
#include <iostream>
#include <vector>
#include <limits>

using namespace std;

void merge(vector<int>& A, int p, int q, int r){
    int n_1 = q-p, n_2 = r+1-q;
    vector<int> L(n_1), R(n_2);
    for (int i = 0; i<n_1; i++){
        L[i] = A[p+i];
    }
    for (int i = 0; i<n_2; i++){
        R[i] = A[q+i];
    }
    // 添加哨兵值
    L.push_back(numeric_limits<int>::max());
    R.push_back(numeric_limits<int>::max());
    int i = 0, j = 0;
    for (int k = p; k < r+1; k++){
        if(L[i]<=R[j]){
            A[k] = L[i];
            i++;
        }
        else{
            A[k] = R[j];
            j++;
        }
    }
}

int main(){
    vector<int> A = {1, 2, 3, 4, 6, 8, 5, 7, 9};
    merge(A, 3, 6, A.size()-1);
    cout << "排序后：";
    for (int i = 0; i<A.size(); i++){
        cout << A[i] << " ";
    }
    return 0;
}
// 排序后：1 2 3 4 5 6 7 8 9 
```
:::

其运行过程如下：

<iframe width="800" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=def%20merge%28A%3A%20list,%20q%3A%20int,%20p%3A%20int,%20r%3A%20int%29%20-%3E%20list%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20A%3A%20%E5%BE%85%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%97%E8%A1%A8%0A%0A%20%20%20%20p%EF%BC%9A%E4%BB%8E%E4%BD%95%E5%A4%84%E5%BC%80%E5%A7%8B%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%28%E5%B7%A6%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%A6%96%E9%83%A8%29%0A%20%20%20%20%0A%20%20%20%20q%EF%BC%9A%E4%B8%A4%E5%AD%90%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2%E7%82%B9%28%E5%8F%B3%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%A6%96%E9%83%A8%29%0A%20%20%20%20%0A%20%20%20%20r%EF%BC%9A%E5%BE%85%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E5%8E%9F%E5%85%88%E5%88%97%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%E6%80%BB%E5%92%8C%0A%20%20%20%20%22%22%22%0A%20%20%20%20L%20%3D%20A%5Bp%3Aq%5D%3B%20R%20%3D%20A%5Bq%3Ar%5D%20%20%23%20%E5%88%87%E5%88%86%E4%B8%BA%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%0A%20%20%20%20L.append%28float%28%22inf%22%29%29%3B%20R.append%28float%28%22inf%22%29%29%20%20%23%20%E6%B7%BB%E5%8A%A0%E5%93%A8%E5%85%B5%E5%80%BC%0A%20%20%20%20i%20%3D%200%3B%20j%20%3D%200%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%A4%E5%AD%90%E5%BA%8F%E5%88%97%E6%8C%87%E9%92%88%0A%20%20%20%20for%20k%20in%20range%28p,%20r%29%3A%0A%20%20%20%20%20%20%20%20if%20L%5Bi%5D%20%3C%3D%20R%5Bj%5D%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20A%5Bk%5D%20%3D%20L%5Bi%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20i%20%3D%20i%20%2B%201%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20A%5Bk%5D%20%3D%20R%5Bj%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20j%20%3D%20j%20%2B%201%0A%20%20%20%20return%20A%0A%0AA%20%3D%20%5B1,%202,%203,%204,%206,%208,%205,%207,%209%5D%0AA%20%3D%20merge%28A,%206,%203,%209%29%0Aprint%28f%22%E6%8E%92%E5%BA%8F%E5%90%8E%EF%BC%9A%7BA%7D%22%29&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=35&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">

</iframe>

该合并算法需要 $\Theta(n)$ 的时间，每次基本操作是常量时间，而最多执行n个基本步骤。或者可以观察其伪代码，发现就只有一个循环需要运行 $\Theta(n)$ 时间，而循环内的操作都是需要常量时间。 ($n=r-p$)

::: callout-note
## 合并算法正确性

`循环不变式`：在k次迭代时，子数组A\[p..k-1\]按从小到大的顺序包含L\[1..$n_1+1$\]和R\[1..$n_2+1$\]中的 $k-p$ 个最小元素。

-   初始化：易得在第一次迭代前循环不变式成立（平凡）。
-   保持：假设第k次循环 L\[i\]\< R\[j\]，那么此时 A\[p,k-1\]中将会加入L\[i\]，在下次循环前A\[p,k\]中包含的就是L\[1..$n_1+1$\]和R\[1..$n_2+1$\]中的 $k+1-p$ 个最小元素。故保持了循环不变式的成立
-   终止：当k=r+1时循环终止，A\[p..k-1\]包含的元素就是L\[1..$n_1+1$\]和R\[1..$n_2+1$\]中的 $k-p$ 个最小元素，且L,R仅剩下哨兵值。

综上算法成立。
:::

## 归并排序算法

::: panel-tabset
## 伪代码

``` pseudocode
\begin{algorithm}
\caption{MERGE-SORT(A,p,r)}
\begin{algorithmic}
    \State \If{p<r}
    \State $q=\lfloor (p+r)/2 \rfloor$\EndIf
    \State MERGE-SORT(A,p,q)
    \State MERGE-SORT(A,q+1,r)
    \State MERGE(A,p,q,r)
\end{algorithmic}
\end{algorithm}
```

## python

```{python}
import math
def MergeSort(A: list, p: int, r: int):
    if p<r:
        q = math.floor((p+r)/2)  # 对半切分
        MergeSort(A, p, q)  # 切分左半边
        MergeSort(A, q+1, r)  # 切分右半边
        merge(A, p, q+1, r)

A = [4, 2, 7, 1, 5, 6, 3, 8]
MergeSort(A, 0, len(A)-1)
print(f"排序后：{A}")
```

## C++

``` cpp
void MergeSort(vector<int>& A, int p, int r){
    if (p<r) {
        int q = static_cast<int>((p+r)/2);
        MergeSort(A, p, q);
        MergeSort(A, q+1, r);
        merge(A, p, q+1, r);
    }
}

int main(){
    vector<int> A = {4, 2, 7, 1, 5, 6, 3, 8};
    MergeSort(A, 0, A.size()-1);
    cout << "排序后：";
    for (int i = 0; i<A.size(); i++){
        cout << A[i] << " ";
    }
    return 0;
}
// 排序后：1 2 3 4 5 6 7 8
```
:::

其运行过程如下：

<iframe width="800" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=def%20merge%28A%3A%20list,%20p%3A%20int,%20q%3A%20int,%20r%3A%20int%29%3A%0A%20%20%20%20L%20%3D%20A%5Bp%3Aq%5D%3B%20R%20%3D%20A%5Bq%3Ar%2B1%5D%20%20%23%20%E5%88%87%E5%88%86%E4%B8%BA%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%0A%20%20%20%20L.append%28float%28%22inf%22%29%29%3B%20R.append%28float%28%22inf%22%29%29%20%20%23%20%E6%B7%BB%E5%8A%A0%E5%93%A8%E5%85%B5%E5%80%BC%0A%20%20%20%20i%20%3D%200%3B%20j%20%3D%200%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%A4%E5%AD%90%E5%BA%8F%E5%88%97%E6%8C%87%E9%92%88%0A%20%20%20%20for%20k%20in%20range%28p,%20r%2B1%29%3A%0A%20%20%20%20%20%20%20%20if%20L%5Bi%5D%20%3C%3D%20R%5Bj%5D%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20A%5Bk%5D%20%3D%20L%5Bi%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20i%20%3D%20i%20%2B%201%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20A%5Bk%5D%20%3D%20R%5Bj%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20j%20%3D%20j%20%2B%201%0A%0Aimport%20math%0Adef%20MergeSort%28A%3A%20list,%20p%3A%20int,%20r%3A%20int%29%3A%0A%20%20%20%20if%20p%3Cr%3A%0A%20%20%20%20%20%20%20%20q%20%3D%20math.floor%28%28p%2Br%29/2%29%20%20%23%20%E5%AF%B9%E5%8D%8A%E5%88%87%E5%88%86%0A%20%20%20%20%20%20%20%20MergeSort%28A,%20p,%20q%29%20%20%23%20%E5%88%87%E5%88%86%E5%B7%A6%E5%8D%8A%E8%BE%B9%0A%20%20%20%20%20%20%20%20MergeSort%28A,%20q%2B1,%20r%29%20%20%23%20%E5%88%87%E5%88%86%E5%8F%B3%E5%8D%8A%E8%BE%B9%0A%20%20%20%20%20%20%20%20merge%28A,%20p,%20q%2B1,%20r%29%0A%0AA%20%3D%20%5B4,%202,%207,%201,%205,%206,%203,%208%5D%0AMergeSort%28A,%200,%20len%28A%29-1%29%0Aprint%28f%22%E6%8E%92%E5%BA%8F%E5%90%8E%EF%BC%9A%7BA%7D%22%29&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">

</iframe>

## 分析分治算法

这种归并排序的时间可由下式表示：

$$
T(n)=\begin{cases}
\Theta(1)&n\leq c\\
aT(n/b)+D(n)+C(n)&\text{其他}
\end{cases}
$$

上式当问题规模足够小时，仅需常量时间。而当问题规模 $n>c$ 时，原问题解决的时间由以下三部分构成：

-   解决被分解后规模相当于原问题 $1/b$ 的a个子问题所耗费的时间 $aT(n/b)$
-   分解成子问题所需要的时间 $D(n)$
-   合并子问题成原问题的解需要的时间 $C(n)$

### 归并排序算法时间复杂度分析

-   分割：易得分解子问题的时间易得为常数时间。
-   解决：为了便于分析此处假定问题的规模为2的幂数倍，则规模为 $n$ 的原问题将会被分割为2个规模为 $n/2$ 的子问题，解决这些子问题的时间为 $2T(n/2)$。
-   合并：在归并排序算法中合并子问题的时间由上述分析得为 $\Theta(n)$

综上有如下公式： $$
T(n)=\begin{cases}
\Theta(1)&n\leq 1\\
2T(n/2)+\Theta(n)&\text{其他}
\end{cases}
$$

![归并排序算法时间分析](images/paste-1.jpeg){width="460"}

即归并排序算法的时间为 $\Theta(n\log_2n)$