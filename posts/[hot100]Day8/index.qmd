---
title: "Day8"
date: 2025/03/03
categories: [刷题, 算法]
description: "介绍有关线性表中数组部分的排序序列、有效数独、接雨水、旋转图像、加一"
---

# 预备知识

今天主要涉及康托编码的原理、

## 康托编码

康托展开式全排列与自然数的双射，常用于空间压缩，本质上是计算当前排列在所有由小到大全排列中的顺序，因此可逆。

### 排列 $\to$ 自然数

求`34152`在全排列中的位置

1.  第一位小于3的所有数有：$2\times 4!$
2.  第2位小于4的所有数：$2\times 3!$(3由于被第一位占了所以是 $2\times$)
3.  第三位小于1的所有数：无
4.  第4位小于5的所有数：$1\times 1!$
5.  第5位小于2的所有数：$0$

则其编号为 $2 \times 4! + 2 \times 3! + 0 \times 2! + 1 \times 1! + 0 \times 0! = 61$

### 自然数 $\to$ 排列

编号X=61

1.  第1位：$\frac{61}{4} = 2 \cdots \cdots 13$，说明比第1位小的有2个，ans\[0\]=3

2.  第2位：$\frac{13}{3} = 2 \cdots \cdots 1$，说明比第2位小的有2个，a\[1\]=4

3.  第3位：$\frac{1}{2} = 0 \cdots \cdots 1$，说明比第3位小的有0个，ans\[2\]=1

4.  第4位：$\frac{1}{1} = 1 \cdots \cdots 0$，说明比第4位小的有1个，ans\[3\]=5

5.  第5位：剩下2，ans\[4\]=2

# 排序序列

![](images/paste-1.png)

::: callout-note
# 分析

采用康托解码即可解决
:::

::: panel-tabset
# Python

``` python
class Solution:
    def getPermutation(self, n: int, k: int) -> str:
        # 计算阶乘
        factorial = [1] * n  # 存储0!到(n-1)!
        for i in range(1, n):
            factorial[i] = factorial[i - 1] * i
        
        # 初始化可用数字列表
        available = list(range(1, n + 1))
        result = []
        k -= 1  # 转换为0-based索引

        for i in range(n - 1, -1, -1):
            # 确定当前位的数字在available中的索引
            index = k // factorial[i]
            result.append(str(available.pop(index)))
            k %= factorial[i]
        
        return ''.join(result)
```

# C++

``` cpp
class Solution {
public:
    string getPermutation(int n, int k) {
        string s(n, '0');
        string result;
        for (int i = 0; i < n; ++i)
            s[i] += i + 1;
        return kth_permutation(s, k);
    }

private:
    int factorial(int n) {
        int result = 1;
        for (int i = 1; i <= n; ++i)
            result *= i;
        return result;
    }
    template <typename Sequence>
    Sequence kth_permutation(const Sequence& seq, int k) {
        const int n = seq.size();
        Sequence S(seq);
        Sequence result;
        int base = factorial(n - 1);
        --k;
        for (int i = n - 1; i > 0; k %= base, base /= i, --i) {
            auto a = next(S.begin(), k / base);
            result.push_back(*a);
            S.erase(a);
        }
        result.push_back(S[0]);
        return result;
    }
};
```
:::

# 有效数独

![](images/paste-2.png)

::: callout-note
# 分析

仅需按照题目要求进行遍历即可
:::

::: panel-tabset
# Python

``` python
class Solution:
    def check(self, item: str, check_list: List[List[bool]]) -> bool:
        if item == ".": return True
        elif check_list[int(item) - 1]: return False
        else:
            check_list[int(item) - 1] = True  # <1>
            return True

    def isValidSudoku(self, board: List[List[str]]) -> bool:
        n = len(board)
        check_list = [False] * n
        for i in range(n):
            check_list = [False] * n
            for j in range(n):  # 遍历行
                if not self.check(board[i][j], check_list):
                    return False
            check_list = [False] * n
            for k in range(n):  # 遍历列
                if not self.check(board[k][i], check_list):
                    return False
        for r in range(3):
            check_list = [False] * n
            for c in range(3):
                check_list = [False] * n
                for i in range(3 * r, 3 * (r + 1)):  # <2>
                    for j in range(3 * c, 3 * (c + 1)):
                        if not self.check(board[i][j], check_list):
                            return False
        return True
```

1.  注意不要用`==`
2.  仅遍历0-3是不对的，应当乘以倍数

``` cpp
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        bool used[9];
        for (int i = 0; i < 9; ++i) {
            fill(used, used + 9, false);
            for (int j = 0; j < 9; ++j) if (!check(board[i][j], used)) return false;
            fill(used, used + 9, false);
            for (int j = 0; j < 9; ++j) if (!check(board[j][i], used)) return false;
        }

        for (int r = 0; r < 3; r++) {
            for (int c = 0; c < 3; c++) {
                fill(used, used + 9, false);
                for (int i = 3 * r; i < 3 * r + 3; i++){
                    for (int j = 3 * c; j < 3 * c + 3; j++) if (!check(board[i][j], used)) return false;
                }
            }
        }
        return true;

    }

private:
    bool check(char item, bool used[9]) {
        if (item == '.') return true;  // <1>
        else if (used[item - '1']) return false;
        else return used[item - '1'] = true;
    }
};
```

1.  C++中仅用''表示单字符char；用""表示字符串string
:::

# 接雨水

![](images/paste-3.png)

::: callout-note
# 分析

本例中在最高峰在左侧只要你的高度低于左侧最高便可蓄水 max_left - height\[i\]；在最高峰的右侧，只要你的的高度低于右侧最高峰便可蓄水 max_right - height\[j\]。
:::

::: panel-tabset
# Python

``` python
class Solution:
    def trap(self, height: List[int]) -> int:
        max = 0
        for i in range(len(height)):
            if height[i] > height[max]: max = i
        peak = 0
        water = 0
        for i in range(max): 
            if height[i] > peak: peak = height[i]
            water += peak - height[i]
        top = 0
        for j in range(len(height) - 1, max , -1):
            if height[j] > top: top = height[j]
            water += top - height[j]
        return water
```

# C++

``` cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int max = 0;
        for (int i = 0; i < height.size(); i++) if (height[i] > height[max]) max = i;
        int water = 0;
        for (int i = 0, peak = 0; i < max; i++) {
            if (height[i] > peak) peak = height[i];
            water += peak - height[i];
        } 

        for (int j = height.size() - 1, top = 0; j > max; j--) {
            if (height[j] > top) top = height[j];
            water += top - height[j];
        }
        return water;
    }
};
```
:::


# 旋转图像

::: callout-note
# 分析

顺时针旋转90度相当于先水平对称而后再沿主对角线对称

:::


::: panel-tabset
# Python
```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        for i in range(n // 2):  # <1>
            a = matrix[n-i-1]
            matrix[n-i-1] = matrix[i]
            matrix[i] = a
        # 沿主对角线对称
        for i in range(n):  # <2>
            for j in range(i+1, n):  # 防止选到负索引
                a = matrix[j][i]
                matrix[j][i] = matrix[i][j]
                matrix[i][j] = a
```
1. 由于python列表的组织形式可以直接一片片的对称过去
2. 顺时针旋转90度相当于先水平对称而后再沿主对角线对称

# C++
```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        vector<int> a;
        for (int i = 0; i < n / 2; i++) swap(matrix[i], matrix[n - i - 1]);  // <1>

       // 对角线交换
        for(int i = 0; i < n; ++i){
            for(int j = i + 1; j < n; ++j) swap(matrix[i][j], matrix[j][i]);
        }
    }
};
```
1. 采用swap进行交换这里，`matrix[n-i-1]` 和 `matrix[i]` 是整行引用，但在 C++ 中，直接赋值会导致浅拷贝，无法正确交换两行的所有元素。此外，如果想交换两行，应该逐个元素交换，或者使用标准库提供的 swap 函数。(这和python存在区别)

:::