---
title: "Day10"
date: 2025/03/08
categories: [刷题, 算法]
description: "介绍有关线性表中数组部分的爬楼梯"
---

# 爬楼梯

![](images/paste-1.png)

::: callout-note
# 分析

假设 $f(n)$ 表示为爬n阶楼梯的不同方法，为了爬到第n阶台阶的方法数有：

$$
f(n) = f(n-1) + f(n-2)
$$

上式是一个斐波那契数列，数列的通项为：

$$
a_n=\frac 1 {\sqrt{5}} [(\frac{(1+\sqrt 5)^n}{2})-\frac{(1-\sqrt 5)^n}{2}]
$$
:::

::: panel-tabset
# Python

``` python
class Solution:
    def climbStairs(self, n: int) -> int:
        prev = 2
        pprev = 1
        if n == 1:
            return 1
        if n == 2:
            return 2
        for _ in range(2, n):
            now = prev + pprev
            pprev = prev
            prev = now
        return now
```

# C++

``` cpp
class Solution {
public:
    int climbStairs(int n) {
        int prev = 2, pprev = 1;
        if (n == 1) return 1;
        if (n == 2) return 2;
        int now;
        for (int i = 2; i < n; i++) {
            now = prev + pprev;
            pprev = prev;
            prev = now;
        }
        return now;
    }
};
```
:::

# 格雷码

![](images/paste-3.png)

::: callout-note
# 分析

数字n的格雷码为：

$$
\text{Graycode}(n)=n\oplus\lfloor n/2\rfloor
$$
:::

::: panel-tabset
# Python

``` python
class Solution:
    def grayCode(self, n: int) -> List[int]:
        result_list = []
        for i in range(2**n):
            item = i ^ int(i / 2)
            result_list.append(item)
        return result_list
```

``` cpp
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> result;
        for (int i = 0; i < pow(2, n); i++) result.push_back(i ^ (i >> 1));  // <1>
        return result;
    }
};
```

1.  C++中计算幂函数的方式为`pow()` 函数
:::

# 矩阵置零

![](images/paste-4.png)

::: callout-note
# 分析

就首先按行搜索，记录存在0元素的列，而后将列均赋值为0，easy🤟
:::

::: panel-tabset
# Python

``` python
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        m = len(matrix); n = len(matrix[0])
        zero_col = []
        for i in range(m):
            zero_indicator = False
            for fast in range(n):
                if matrix[i][fast] == 0:
                    zero_indicator = True
                    zero_col.append(fast)
            if zero_indicator:
                for slow in range(n):
                    matrix[i][slow] = 0
        for j in zero_col:
            for i in range(m):
                matrix[i][j] = 0
```

# C++

``` cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<int> zero_col;
        for (int i = 0; i < m; i++) {
            bool zero_indicator = false;
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    zero_indicator = true;
                    zero_col.push_back(j);
                }
            }
            if (zero_indicator) {
                for (int j = 0; j < n; j++) matrix[i][j] = 0;
            }
        }

        for (auto j = zero_col.begin(); j < zero_col.end(); j++) {
            for (int i = 0; i < m; i++) matrix[i][*j] = 0;
        } 
    }
};
```
:::

# 加油站

![](images/paste-5.png)

::: callout-note
# 分析

-   若从某站出发不足以前往下一站便比必不可能作为起始站
-   起始站只能是从某站开始剩余油量始终为非负的
-   可以只遍历一次，一个变量用于检测从某站开始油量的情况，另一个变量用于检测目前整体油量是否有亏欠
:::

::: panel-tabset
# Python

``` python
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        total = 0; j = -1
        sum = 0
        for i in range(len(cost)):
            sum += gas[i] - cost[i]
            total += gas[i] - cost[i]
            if sum < 0:
                j = i
                sum = 0
        return j + 1 if total >= 0 else -1
```

# C++

``` cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int total = 0;
        int j = -1;
        for (int i = 0, sum = 0; i < gas.size(); ++i) {
            sum += gas[i] - cost[i];
            total += gas[i] - cost[i];
            if (sum < 0) {
                j = i;
                sum = 0;
            }
        }
        return total >= 0 ? j + 1 : -1;
    }
};
```
:::
