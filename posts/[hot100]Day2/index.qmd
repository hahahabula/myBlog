---
title: "Day2"
date: 2025/02/24
categories: [算法, 刷题]
description: "线性表中有关数组的搜索旋转排序数组、"
---

# 搜索旋转排序数组

![](images/paste-1.png)

::: callout-note
# 分析

1.  要求时间复杂度为 $\Theta(\log(n))$，目前已知二分查找的复杂度符合
2.  旋转排序数组的特征是从某个位置切下后两边都为有序数组，而从其他位置切下时将会得到一个有序一个无序。
:::

::: panel-tabset
# 伪代码

``` pseudocode
\begin{algorithm}
\caption{searchRotated(A, target)}
\begin{algorithmic}
\State first = 0, last = A.length - 1
\While{first <= last}
    \State mid = $\lfloor first + (last - first)/2 \rfloor$  \Comment{计算中间索引}
    \If{A[mid] == target}
        \State \Return mid  \Comment{如果中间值等于目标值，返回索引}
    \EndIf
    \If{A[first] <= A[mid]}
        \If{A[first] <= target \And target < A[mid]}
            \State last = mid - 1  \Comment{目标值在左侧有序子数组中}
        \Else
            \State first = mid + 1  \Comment{目标值在右侧子数组中}
        \EndIf
    \Else
        \If{A[mid] < target \And target <= A[last]}
            \State first = mid + 1  \Comment{目标值在右侧有序子数组中}
        \Else
            \State last = mid - 1  \Comment{目标值在左侧子数组中}
        \EndIf
    \EndIf
\EndWhile
\State \Return -1  \Comment{未找到目标值，返回-1}
\end{algorithmic}
\end{algorithm}
```

# Python

```{python}
from typing import List
def searchRotated(A: List[int], target: int) -> int:
    import math
    first = 0
    last = len(A) - 1
    while first <= last:
        mid = math.floor(first+(last-first)/2)
        if A[mid]==target:
            return mid
        if A[first]<=A[mid]:
            if A[first]<=target and A[mid]>target:
                last = mid - 1
            else:
                first = mid + 1
        else:
            if A[mid]<target and A[last]>=target:
                first = mid + 1
            else:
                last = mid - 1
    return -1
```

# C++

``` cpp
int searchRotated(vector<int>& nums, int target){
    int first = 0, last = nums.size() - 1;
    while (first<=last){
        int mid = first + (last - first) / 2;
        if (nums[mid]==target){
            return mid;
        }        
        if (nums[first]<=nums[mid]){
            if (nums[first]<=target && nums[mid]>target){
                last = mid - 1;
            }
            else first = mid + 1;
        }
        else{
            if (nums[mid]<target && nums[last]>=target){
                first = mid + 1;
            }
            else last = mid - 1;
        }
    }
    return -1;
}
```
:::

# 搜索旋转排序数组Ⅱ

![](images/paste-2.png)

::: {.callout-note}
# 分析
该问题与上一个问题的区别在于元素可重复，元素可重复并没有改变当从数组中间切一刀时将会得到一个有序的子数组和一个无序的子数组的事实，但是会造成无法通过`A[first]<=A[mid]`来判断是否为有序数列如`[1,3,1,1,1]`，因此需要修改。
- 若`A[first]<A[mid]`，则必可说明`A[first..mid]`为有序数组。
- 若`A[first]>A[mid]`，则必可说明`A[first..mid]`为无序数组，`A[mid..last]`为有序数组。
- 若`A[first]=A[mid]`，则可通过`first=first+1`的形式避免这种情况，由于mid处和first处值一致因此直接删除first处的值也无碍。
:::

::: panel-tabset
# 伪代码
```pseudocode
\begin{algorithm}
\caption{searchRotated2(nums, target)}
\begin{algorithmic}
\State $first \gets 0$
\State $last \gets \text{length}(nums) - 1$
\While{$first \leq last$}
    \State $mid \gets \lfloor first + \frac{(last - first)}{2} \rfloor$
    \If{$nums[mid] = target$}
        \State \Return true
    \EndIf
    \If{$nums[first] < nums[mid]$}
        \If{$nums[first] \leq target \And target < nums[mid]$}
            \State $last \gets mid - 1$
        \Else
            \State $first \gets mid + 1$
        \EndIf
    \ElsIf{$nums[first] > nums[mid]$}
        \If{$nums[mid] < target \And nums[last] \geq target$}
            \State $first \gets mid + 1$
        \Else
            \State $last \gets mid - 1$
        \EndIf
    \Else
        \State $first \gets first + 1$
    \EndIf
\EndWhile
\State \Return $false$
\end{algorithmic}
\end{algorithm}
```
# Python
```{python}
from typing import List
def searchRotated(A: List[int], target: int) -> int:
    import math
    first = 0
    last = len(A) - 1
    while first <= last:
        mid = math.floor(first+(last-first)/2)
        if A[mid]==target:
            return True
        if A[first]<A[mid]:
            if A[first]<=target and A[mid]>target:
                last = mid - 1
            else:
                first = mid + 1
        elif A[first]>A[mid]:
            if A[mid]<target and A[last]>=target:
                first = mid + 1
            else:
                last = mid - 1
        else:
            first += 1
    return False
```

# C++
```c++
bool search(vector<int>& nums, int target) {
        int first = 0, last = nums.size() - 1;
        while (first<=last){
            int mid = first + (last - first) / 2;
            if (nums[mid]==target){
                return true;
            }        
            if (nums[first]<nums[mid]){
                if (nums[first]<=target && nums[mid]>target){
                    last = mid - 1;
                }
                else first = mid + 1;
            }
            else if (nums[first]>nums[mid]){
                if (nums[mid]<target && nums[last]>=target){
                    first = mid + 1;
                }
                else last = mid - 1;
            }
            else first++;
        }
        return false;
    }
```
:::

