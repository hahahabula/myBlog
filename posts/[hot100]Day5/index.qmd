---
title: "Day5"
date: 2025/02/27
categories: [åˆ·é¢˜, ç®—æ³•]
description: "ä»‹ç»æœ‰å…³çº¿æ€§è¡¨ä¸­æ•°ç»„éƒ¨åˆ†çš„æœ€é•¿è¿ç»­åºåˆ—å’Œä¸¤æ•°ä¹‹å’Œ"
---

# æœ€é•¿è¿ç»­åºåˆ—

![](images/paste-1.png)

::: callout-note
# åˆ†æ

ç”±äºè¦æ±‚æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ï¼ŒåŒæ—¶è¯¥é¢˜çš„æœ¬è´¨åœ¨äºæŸ¥è¯¢ï¼Œå“ˆå¸Œè¡¨çš„æŸ¥è¯¢æ•ˆç‡å°±æ˜¯ $O(1)$ ã€‚å› æ­¤å¯ä»¥é‡‡ç”¨å“ˆå¸Œè¡¨è¿›è¡ŒæŸ¥è¯¢åŒæ—¶éå†æ‰€æœ‰å€¼
:::

::: panel-tabset
# ä¼ªä»£ç 

``` pseudocode
\begin{algorithm}
\caption{longestConsecutive(nums)}
\begin{algorithmic}
\State å“ˆå¸Œè¡¨ used
\For{i in nums}
    \State used[i] = false \Comment{åˆå§‹åŒ–æ‰€æœ‰ç´¢å¼•è®¤ä¸ºå‡æœªéå†}
\EndFor
\State longest = 0\Comment{è®¾ç½®åˆå§‹åŒ–æœ€å¤§è¿ç»­é•¿åº¦}
\For{i in nums}\Comment{å¼€å§‹éå†å…¨éƒ¨å…ƒç´ è¿™ä¹Ÿæ˜¯æ—¶é—´å¤æ‚åº¦ä¸º$O(n)$çš„åŸå› }
    \If{used[i]}
        \Continue\Comment{è‹¥è¢«éå†è¿‡è¯´æ˜å…¶å·²æ‰¾åˆ°å±äºå®ƒçš„æœ€å¤§è¿ç»­å­æ•°ç»„ï¼Œæ²¡æœ‰å¿…è¦å†éå†}
    \EndIf
    \State length = 1\Comment{åˆå§‹åŒ–æœ€å¤§è¿ç»­é•¿åº¦}
    \State used[i] = True\Comment{æ ‡è®°è¯¥å…ƒç´ å·²ç»è¢«éå†}
    \State j = i + 1\Comment{å¼€å§‹éå†å…¶å³ä¾§çš„å€¼ç›´è‡³ä¸å†è¿ç»­}
    \While{j in used.keys}
        \State used[j] = true
        \State length += 1\Comment{æ‰¾åˆ°äº†ä¸€ä¸ªè¿ç»­çš„}
        \State j += 1
    \EndWhile
    \State j = i - 1\Comment{ç»§ç»­å¯»æ‰¾iå·¦ä¾§çš„è¿ç»­å€¼}
    \While{j in used.keys}
        \State used[j] = true
        \State length += 1
        \State j -= 1
    \EndWhile
    \State longest = max(length, longest)
\EndFor
\Return longest
\end{algorithmic}
\end{algorithm}
```

# C++

``` cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_map<int, bool> used;  // åˆ›å»ºå“ˆå¸Œè¡¨
        for (auto i : nums) used[i] = false;
        int longest = 0;
        for (auto i : nums){  // åˆ©ç”¨auto i : numséå†numsä¸­çš„å€¼
            if (used[i]) continue;
            int length = 1;
            used[i] = true;
            for (int j = i + 1; used.find(j) != used.end(); ++j){
                used[j] = true;
                ++length;
            }
            for (int j = i - 1;used.find(j) != used.end(); --j){
                used[j] = true;
                ++length;
            }
            longest = max(longest, length);
        }
        return longest;
    }
};
```

# Python

``` python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        used = dict();
        for i in nums:
            used[i] = False
        longest = 0
        for i in nums:
            if used[i]: continue
            length = 1
            used[i] = True
            j = i + 1
            while j in used:
                used[j] = True
                length += 1
                j += 1
            j = i - 1
            while j in used:
                used[j] = True
                length += 1
                j -= 1
            longest = max(length, longest)
        return longest
        
```
:::

# ä¸¤æ•°ä¹‹å’Œ

![](images/paste-2.png)

::: callout-note
# åˆ†æ

ä¸ºäº†å°½é‡ä½¿æ—¶é—´å¤æ‚åº¦è¾ƒä½ï¼Œç°åˆ†æå‡ ç§æ–¹æ³•ï¼š

-   æš´åŠ›æšä¸¾æ³•($C_n^2\to O(n^2)$)
-   å…ˆæ’åº($O(n\log n)$)åå¤¹é€¼($O(n)$)ï¼Œæœ€ç»ˆ $O(n\log n)$
-   å“ˆå¸Œï¼šç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨ï¼Œå­˜å‚¨æ¯ä¸ªæ•°å¯¹åº”çš„ä¸‹æ ‡ï¼Œå¤æ‚åº¦ $O(n)$
:::

::: panel-tabset
# ä¼ªä»£ç 

è¯¥é¢˜è¾ƒä¸ºç®€å•æš‚ä¸ä¹¦å†™ä¼ªä»£ç ğŸ˜ƒ

# Python

``` python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        used = dict()
        for i in range(len(nums)): used[nums[i]] = i  # æ­¤å¤„ä¾¿ä¿è¯äº†ä»…æœ‰è¾ƒåçš„ç´¢å¼•ä¼šç•™ä¸‹åœ¨è¿”å›å€¼æ—¶æ— éœ€å†åˆ¤æ–­ç´¢å¼•çš„å¤§å°å…³ç³»
        for i, num in enumerate(nums):
            remain = target - num
            if remain in used and used[remain] > i:
                return [i, used[remain]]
```

# C++

``` cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> mapping;
        vector<int> result;
        for (int i = 0; i < nums.size(); i++) mapping[nums[i]] = i;
        for (int i = 0; i < nums.size(); i++){
            int gap = target - nums[i];
            if (mapping.find(gap) != mapping.end() && mapping[gap] > i){
                result.push_back(i);
                result.push_back(mapping[gap]);
            }
        }
        return result;

    }
};
```
:::

